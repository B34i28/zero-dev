"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignTypedDataParamsData = exports.getSignParamsMessage = exports.convertHexToUtf8 = exports.WalletConnect = exports.setupWalletConnect = void 0;
const client_1 = __importDefault(require("@walletconnect/client"));
const utils_1 = require("@json-rpc-tools/utils");
const ethers_1 = require("ethers");
const ethers_eip712_1 = require("ethers-eip712");
const setupWalletConnect = (signer, hooks) => {
    // set a default disconnect hook
    if (!hooks.disconnect) {
        hooks.disconnect = deleteCachedLegacySession;
    }
    return new WalletConnect(signer, hooks);
};
exports.setupWalletConnect = setupWalletConnect;
function deleteCachedLegacySession() {
    console.log('clearing local storage for walletconnect disconnect');
    if (typeof window === 'undefined')
        return;
    window.localStorage.removeItem('walletconnect');
}
class WalletConnect {
    constructor(signer, hooks) {
        this.signer = signer;
        this.hooks = hooks;
    }
    // slight optimization
    async getAddress() {
        if (this.address) {
            return this.address;
        }
        this.address = await this.signer.getAddress();
        return this.address;
    }
    async getChainId() {
        if (this.chainId) {
            return this.chainId;
        }
        this.chainId = await this.signer.getChainId();
        return this.chainId;
    }
    pair(uri) {
        this.client = new client_1.default({ uri });
        this.client.on('session_request', (error, payload) => {
            if (error) {
                throw new Error(`legacySignClient > session_request failed: ${error}`);
            }
            this.hooks.onSessionRequest(payload, 
            // approve
            async () => {
                const address = await this.getAddress();
                const chainId = await this.getChainId();
                this.client.approveSession({
                    accounts: [address],
                    chainId: chainId,
                });
            }, 
            // reject
            async () => {
                this.client.rejectSession({
                    message: 'User rejected session',
                });
            });
        });
        this.client.on('call_request', (error, payload) => {
            if (error) {
                throw new Error(`legacySignClient > call_request failed: ${error}`);
            }
            this.onCallRequest(payload);
        });
        this.client.on('disconnect', async () => {
            var _a, _b;
            (_b = (_a = this.hooks).disconnect) === null || _b === void 0 ? void 0 : _b.call(_a);
        });
    }
    async onCallRequest(payload) {
        const { id, method, params } = payload;
        const chainId = (await this.getChainId()).toString();
        const approve = async () => {
            const { result } = (await this.approveEIP155Request({
                id,
                topic: '',
                params: { request: { method, params }, chainId }
            }));
            this.client.approveRequest({
                id,
                result
            });
        };
        const reject = async () => {
            const { error } = this.rejectEIP155Request({
                id,
                topic: '',
                params: { request: { method, params }, chainId }
            });
            this.client.rejectRequest({
                id,
                error
            });
        };
        switch (method) {
            case EIP155_SIGNING_METHODS.ETH_SIGN:
            case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
                return this.hooks.onSignMessage(payload, this.client.session, approve, reject);
            case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
            case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
            case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
                return this.hooks.onSignTypedData(payload, this.client.session, approve, reject);
            case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
            case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
                return this.hooks.onSendTransaction(payload, this.client.session, approve, reject);
            default:
                alert(`${method} is not supported for WalletConnect v1`);
        }
    }
    async approveEIP155Request(requestEvent) {
        const { params, id } = requestEvent;
        const { request } = params;
        const accountAddress = await this.getAddress();
        switch (request.method) {
            case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
            case EIP155_SIGNING_METHODS.ETH_SIGN:
                const message = getSignParamsMessage(request.params);
                const dataHash = ethers_1.utils.arrayify(ethers_1.utils.hashMessage(message));
                const sig = await this.signer.signMessage(dataHash);
                return (0, utils_1.formatJsonRpcResult)(id, sig);
            case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
            case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
            case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
                const typedData = getSignTypedDataParamsData(request.params);
                const digest = ethers_eip712_1.TypedDataUtils.encodeDigest(typedData);
                const signedData = await this.signer.signMessage(digest);
                return (0, utils_1.formatJsonRpcResult)(id, signedData);
            case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
                const sendTransaction = request.params[0];
                // our SDK expects `gasLimit` and breaks when `gas` is set 
                sendTransaction.gasLimit = sendTransaction.gas;
                delete sendTransaction.gas;
                // get the actual txn hash
                const resp = await this.signer.sendTransaction(sendTransaction);
                const receipt = await resp.wait();
                return (0, utils_1.formatJsonRpcResult)(id, receipt['bundleTransactionHash']);
            case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
                const signTransaction = request.params[0];
                const signature = await this.signer.signTransaction(signTransaction);
                return (0, utils_1.formatJsonRpcResult)(id, signature);
            default:
            // throw new Error(getSdkError('INVALID_METHOD').message)
        }
    }
    rejectEIP155Request(request) {
        const { id } = request;
        return (0, utils_1.formatJsonRpcError)(id, 'User rejected request');
    }
}
exports.WalletConnect = WalletConnect;
const EIP155_SIGNING_METHODS = {
    PERSONAL_SIGN: 'personal_sign',
    ETH_SIGN: 'eth_sign',
    ETH_SIGN_TRANSACTION: 'eth_signTransaction',
    ETH_SIGN_TYPED_DATA: 'eth_signTypedData',
    ETH_SIGN_TYPED_DATA_V3: 'eth_signTypedData_v3',
    ETH_SIGN_TYPED_DATA_V4: 'eth_signTypedData_v4',
    ETH_SEND_RAW_TRANSACTION: 'eth_sendRawTransaction',
    ETH_SEND_TRANSACTION: 'eth_sendTransaction'
};
/**
 * Converts hex to utf8 string if it is valid bytes
 */
function convertHexToUtf8(value) {
    if (ethers_1.utils.isHexString(value)) {
        return ethers_1.utils.toUtf8String(value);
    }
    return value;
}
exports.convertHexToUtf8 = convertHexToUtf8;
/**
 * Gets message from various signing request methods by filtering out
 * a value that is not an address (thus is a message).
 * If it is a hex string, it gets converted to utf8 string
 */
function getSignParamsMessage(params) {
    const message = params.filter(p => !ethers_1.utils.isAddress(p))[0];
    return convertHexToUtf8(message);
}
exports.getSignParamsMessage = getSignParamsMessage;
/**
 * Gets data from various signTypedData request methods by filtering out
 * a value that is not an address (thus is data).
 * If data is a string convert it to object
 */
function getSignTypedDataParamsData(params) {
    const data = params.filter(p => !ethers_1.utils.isAddress(p))[0];
    if (typeof data === 'string') {
        return JSON.parse(data);
    }
    return data;
}
exports.getSignTypedDataParamsData = getSignTypedDataParamsData;
//# sourceMappingURL=walletconnect.js.map