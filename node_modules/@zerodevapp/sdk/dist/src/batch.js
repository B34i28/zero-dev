"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execBatch = void 0;
const ethers_1 = require("ethers");
const ERC4337EthersSigner_1 = require("./ERC4337EthersSigner");
// The deterministic address using solidity 0.8.15
const MULTISEND_ADDR = '0x8ae01fcf7c655655ff2c6ef907b8b4718ab4e17c';
// Adopted from: https://github.com/safe-global/safe-contracts/blob/821d5fbdc2a4e7776d66c9f232b000b81e60bffc/src/utils/multisend.ts
const encodeCall = (call) => {
    const data = ethers_1.utils.arrayify(call.data);
    const encoded = ethers_1.utils.solidityPack(["uint8", "address", "uint256", "uint256", "bytes"], [call.delegateCall ? 1 : 0, call.to, call.value || 0, data.length, data]);
    return encoded.slice(2);
};
const encodeMultiSend = (calls) => {
    return "0x" + calls.map((call) => encodeCall(call)).join("");
};
function execBatch(signer, calls, options) {
    if (!(signer instanceof ERC4337EthersSigner_1.ERC4337EthersSigner)) {
        throw new Error('execBatch only works with a ZeroDev signer');
    }
    const delegateSigner = signer.delegateCopy();
    const multiSend = new ethers_1.Contract(MULTISEND_ADDR, [
        'function multiSend(bytes memory transactions)',
    ], delegateSigner);
    // TODO: hardcoding gas is bad.  we have to do this because the gas
    // estimation is failing due to internally when it calls populateTransaction()
    // in sendTransaction(), it estimates the call using call not delegate call
    return multiSend.multiSend(encodeMultiSend(calls), {
        gasLimit: options === null || options === void 0 ? void 0 : options.gasLimit,
        gasPrice: options === null || options === void 0 ? void 0 : options.gasPrice,
    });
}
exports.execBatch = execBatch;
//# sourceMappingURL=batch.js.map