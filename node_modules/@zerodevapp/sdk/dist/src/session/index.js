"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.revokeSessionKey = exports.deserializeSessionKeyData = exports.serializeSessionKeyData = exports.createSessionKeySigner = exports.createSessionKey = void 0;
const contracts_new_1 = require("@zerodevapp/contracts-new");
const base64 = __importStar(require("base64-js"));
const merkletreejs_1 = require("merkletreejs");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const SessionSigner_1 = require("./SessionSigner");
const api = __importStar(require("../api"));
const constants = __importStar(require("../constants"));
const utils_2 = require("../utils");
const KernelAccountAPI_1 = require("../KernelAccountAPI");
const HttpRpcClient_1 = require("../HttpRpcClient");
const ZeroDevProvider_1 = require("../ZeroDevProvider");
const accounts_1 = require("../accounts");
const paymasters_1 = require("../paymasters");
const providers_1 = require("@ethersproject/providers");
async function createSessionKey(from, whitelist, validUntil, sessionKeyAddr, sessionKeyPlugin) {
    let sessionPublicKey, sessionPrivateKey;
    if (sessionKeyAddr) {
        sessionPublicKey = sessionKeyAddr;
    }
    else {
        const sessionSigner = ethers_1.Wallet.createRandom().connect(from.provider);
        sessionPublicKey = await sessionSigner.getAddress();
        sessionPrivateKey = sessionSigner.privateKey;
    }
    const plugin = sessionKeyPlugin ? sessionKeyPlugin : contracts_new_1.ZeroDevSessionKeyPlugin__factory.connect(SessionSigner_1.DEFAULT_SESSION_KEY_PLUGIN, from.provider);
    let policyPacked = [];
    for (let policy of whitelist) {
        if (policy.selectors === undefined || policy.selectors.length == 0) {
            policyPacked.push((0, utils_1.hexConcat)([policy.to]));
        }
        else {
            for (let selector of policy.selectors) {
                policyPacked.push((0, utils_1.hexConcat)([policy.to, selector]));
            }
        }
    }
    const merkleTree = policyPacked.length == 0 ? new merkletreejs_1.MerkleTree([(0, utils_1.hexZeroPad)("0x00", 32)], utils_1.keccak256, { hashLeaves: false }) : new merkletreejs_1.MerkleTree(policyPacked, utils_1.keccak256, { sortPairs: true, hashLeaves: true });
    const data = (0, utils_1.hexConcat)([
        (0, utils_1.hexZeroPad)(sessionPublicKey, 20),
        (0, utils_1.hexZeroPad)("0x" + merkleTree.getRoot().toString('hex'), 32),
    ]);
    const sig = await from.approvePlugin(plugin, ethers_1.BigNumber.from(validUntil), ethers_1.BigNumber.from(0), (0, utils_1.hexlify)(data));
    from.smartAccountAPI.owner;
    const sessionKeyData = {
        ownerAddress: await from.originalSigner.getAddress(),
        ownerIndex: await from.smartAccountAPI.index,
        sessionPrivateKey,
        signature: sig,
        whitelist: whitelist,
        validUntil: validUntil,
    };
    return serializeSessionKeyData(sessionKeyData);
}
exports.createSessionKey = createSessionKey;
async function createSessionKeySigner(params) {
    var _a, _b, _c;
    const sessionKeyData = deserializeSessionKeyData(params.sessionKeyData);
    if (!sessionKeyData.sessionPrivateKey && !params.privateSigner) {
        throw new Error('Session key data does not contain session private key and no session key signer was provided');
    }
    if (sessionKeyData.sessionPrivateKey && params.privateSigner) {
        throw new Error('Session key data contains session private key and session key signer was provided');
    }
    const chainId = await api.getChainId(params.projectId, constants.BACKEND_URL);
    const providerUrl = (0, utils_2.getRpcUrl)(chainId);
    let provider = params.rpcProvider;
    if (provider === undefined) {
        if (providerUrl.includes(constants.INFURA_API_KEY) && ![43114, 43113].includes(chainId)) {
            try {
                provider = new (params.useWebsocketProvider === true && ![137, 80001].includes(chainId) ? providers_1.InfuraWebSocketProvider : providers_1.InfuraProvider)(chainId, constants.INFURA_API_KEY);
                await provider.detectNetwork();
            }
            catch (_) {
                provider = new providers_1.InfuraProvider(chainId, constants.INFURA_API_KEY);
            }
        }
        else {
            provider = new ethers_1.ethers.providers.JsonRpcProvider({ url: providerUrl, skipFetchSetup: (_a = params.skipFetchSetup) !== null && _a !== void 0 ? _a : undefined });
        }
    }
    const config = {
        projectId: params.projectId,
        chainId,
        entryPointAddress: constants.ENTRYPOINT_ADDRESS,
        bundlerUrl: params.bundlerUrl || constants.BUNDLER_URL,
        paymasterAPI: await (0, paymasters_1.getPaymaster)(params.projectId, constants.PAYMASTER_URL, chainId, constants.ENTRYPOINT_ADDRESS, params.gasToken),
        implementation: (_b = params.implementation) !== null && _b !== void 0 ? _b : accounts_1.kernelAccount_v1_audited
    };
    const entryPoint = contracts_new_1.EntryPoint__factory.connect(config.entryPointAddress, provider);
    const httpRpcClient = new HttpRpcClient_1.HttpRpcClient(config.bundlerUrl, config.entryPointAddress, chainId, config.projectId, params.skipFetchSetup);
    const accountAPI = new KernelAccountAPI_1.KernelAccountAPI({
        provider,
        entryPointAddress: entryPoint.address,
        owner: new ethers_1.VoidSigner(sessionKeyData.ownerAddress, provider),
        index: sessionKeyData.ownerIndex,
        paymasterAPI: config.paymasterAPI,
        factoryAddress: config.implementation.factoryAddress,
        httpRpcClient
    });
    const aaProvider = await new ZeroDevProvider_1.ZeroDevProvider(chainId, config, accountAPI.owner, provider, httpRpcClient, entryPoint, accountAPI);
    return new SessionSigner_1.SessionSigner(config, aaProvider, httpRpcClient, accountAPI, sessionKeyData.validUntil, sessionKeyData.whitelist, sessionKeyData.signature, (_c = params.privateSigner) !== null && _c !== void 0 ? _c : new ethers_1.Wallet(sessionKeyData.sessionPrivateKey));
}
exports.createSessionKeySigner = createSessionKeySigner;
// Serialize SessionKeyData
function serializeSessionKeyData(sessionKeyData) {
    const jsonString = JSON.stringify(sessionKeyData);
    const uint8Array = new TextEncoder().encode(jsonString);
    const base64String = base64.fromByteArray(uint8Array);
    return base64String;
}
exports.serializeSessionKeyData = serializeSessionKeyData;
// Deserialize SessionKeyData
function deserializeSessionKeyData(base64String) {
    const uint8Array = base64.toByteArray(base64String);
    const jsonString = new TextDecoder().decode(uint8Array);
    const sessionKeyData = JSON.parse(jsonString);
    return sessionKeyData;
}
exports.deserializeSessionKeyData = deserializeSessionKeyData;
async function revokeSessionKey(signer, sessionPublicKey, overrides) {
    const sessionKeyPlugin = contracts_new_1.ZeroDevSessionKeyPlugin__factory.connect(SessionSigner_1.DEFAULT_SESSION_KEY_PLUGIN, signer);
    return await sessionKeyPlugin.revokeSessionKey(sessionPublicKey, overrides !== null && overrides !== void 0 ? overrides : {});
}
exports.revokeSessionKey = revokeSessionKey;
//# sourceMappingURL=index.js.map